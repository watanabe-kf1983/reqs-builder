# reqs-builder

## プロジェクト概要

要件定義を省力化するためのツール。
YAMLでメタデータを記述し、整合性チェックとドキュメント生成（Markdown/Mermaid）を行う。

### 背景

#### 要件定義の最終ゴール

要件定義の最終的なアウトプットは以下：

- **FP法で計測可能な粒度の機能一覧**（最重要）
- その機能一覧の導出根拠となる成果物：
  - ユースケース図、ユースケース記述
  - ファイル一覧
  - ERD（Entity Relationship Diagram）
  - CRUD（Create/Read/Update/Delete）マトリクス
  - DFD（Data Flow Diagram）
- その他：画面一覧、非機能要件など

#### 課題

- **複数の図表間の整合性を取るのが非常に困難**
  - ERD、DFD、CRUD、ユースケースなどは相互に関連している
  - 手作業での整合性維持は見落としが発生しやすい
  - 特にFP法で計測可能な粒度の機能要件を整理するのに難儀している
- 整合性チェックは機械的に行うべき（人間もLLMも見落とす）

#### 検討したアプローチ

**アプローチ1: CLAUDE.md + 直接Markdown編集**
- Claude Codeに言葉で指示しながら、要件定義書のMarkdown/Table/Mermaid.jsを直接編集
- メリット: 柔軟、初期コスト低
- デメリット: 整合性チェックがLLM依存、再現性が低い

**アプローチ2: メタデータ(YAML) + ビルドツール（採用）**
- メタデータをYAMLで記述し、整合性チェックとドキュメント生成を自動化
- メリット: 整合性チェックが確実、再利用可能、FP法計測の自動化も視野
- デメリット: 初期のスキーマ設計コストがかかる

→ **アプローチ2を採用**。まずは動くものを早く作り、価値を実証してからJava版へ移植する戦略。

### アプローチ

```
[対話でヒアリング] → [YAML/JSONメタデータ] → [ビルド] → [Markdown/Mermaid]
        ↑                    ↑
    Claude Code          Claude Code
    (自由対話)           (構造化編集)
```

## アーキテクチャ

本ツールは以下の2つのインターフェースを提供：

1. **CLIツール**: 単体で実行、CI/CDでの利用
2. **MCPサーバ**: Claude Codeとの対話的な要件定義（Vibe要件定義ing）

内部的には同じコアロジック（YAML読み書き、整合性チェック、ドキュメント生成）を共有し、インターフェースのみ分離。

### Vibe要件定義ingの実現

```
[Claude Code + MCP] ←→ [reqs-builder MCP Server]
         ↓
  「ユーザーエンティティを追加して」
  「DFDで外部システムとの連携を確認したい」
  「整合性チェックして」
         ↓
    MCPサーバが実行
         ↓
  YAMLメタデータ更新・検証・可視化
```

対話的にメタデータを構築し、リアルタイムで整合性チェックとドキュメント生成を行う。

## 技術スタック

- 言語: Python 3.11+
- スキーマ定義・検証: Pydantic v2
- YAML処理: PyYAML
- CLI: Typer + Rich
- MCP: Model Context Protocol (将来実装)
- 将来的にJava版への移植を視野に入れる（Pythonで設計を固めてから）

## 開発の優先順位

### Phase 1: ERD + DFD（現在）

1. **ERD + エンティティ**: データモデルの基盤
2. **DFD**: データの流れを可視化、外部インターフェース識別

### 将来の拡張

最終的には以下も扱う予定：

- CRUD マトリクス（機能とエンティティの関係）
- ユースケース図、ユースケース記述
- 機能一覧（FP法計測可能な粒度）
- 画面一覧
- ファイル一覧

## 出力形式

- メタデータ入力: YAML
- ドキュメント出力: Markdown + Mermaid.js

## 設計方針

- 最小限のスキーマから始める（完璧を目指さない）
- YAMLスキーマは言語非依存な設計資産として扱う
- 整合性チェックを重視（エンティティ間の参照整合性など）

## 今後の検討課題

### スキーマの拡張性とカスタマイズ性

要件定義ツールは案件ごとにカスタマイズされる性質を持つ：
- 案件ごとに要件定義の粒度・記法が異なる
- 業界・組織の標準に合わせる必要がある
- FP法の計測ルールも微妙に異なる

**想定される利用形態**:
1. **パッケージ配布**: npm/pip経由でインストール、設定ファイルでカスタマイズ
2. **フォーク運用**: GitHubからフォークし、ソースを直接カスタマイズ

どこまでスキーマ定義に可塑性を持たせるか、実装しながら見極める。

### 移植戦略

Python実装で設計検証後、以下の移植を検討：

**TypeScript版**:
- MCP配布の容易性（npx一発）
- OSS利用者への普及
- Claude Codeとの親和性

**Java版**:
- monocrea案件での利用（Java開発者が多い）
- エンタープライズ現場での受容性
- フォーク前提のカスタマイズ

**検討事項**:
- どちらを優先するか（フィードバック vs 社内利用）
- Python→TypeScript→Java と Python→Java→TypeScript のどちらがスムーズか
