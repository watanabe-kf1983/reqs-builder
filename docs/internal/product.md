# Product Vision

製品ビジョンと背景。

## What

任意の関連するオブジェクト群とドキュメントテンプレートから、整合性の取れた構造的ドキュメントを生成する汎用ツール。

## Why

### 背景と経緯

元々は「要件定義を省力化するツール（reqs-builder）」として構想。
ERD、DFD、CRUDマトリクス等の要件定義成果物を生成しようとしていた。

議論の過程で、本質的に必要なのは以下だと気づいた：

- DFD/ERD等のスキーマ定義は「設定データ」に過ぎない
- 整合性チェックは FK 制約として汎用的に表現できる
- 作るべきは**汎用ドキュメントジェネレータ**である

詳細な経緯: [reqs-builder-original.md](reqs-builder-original.md)

## Key Concepts

- **Schema**: データ構造と参照制約を定義（OpenAPI/JSON Schema + x-ref 拡張）
- **Data**: 実際の値（YAML ファイル群、Git管理）
- **Reports**: 何を、どこに、どういう構造で出力するか
- **Templates**: 見た目の定義（Nunjucks + JSONPath）
- **Validation**: 参照整合性チェック（FK制約相当）

## Core Design Decision

### データとビューの分離

このツールの核心は「データとビューの分離」である。

```
データ（YAML/Markdown）= Single Source of Truth
     ↓
テンプレートA → ドキュメントA
テンプレートB → ドキュメントB
テンプレートC → ドキュメントC
```

分離しない場合、以下の不整合が発生する：

- ドキュメントAに「ユーザーは〇〇」
- ドキュメントBに「ユーザーは△△」

分離することで、データを一箇所で管理し、整合性を保証する。

### トレードオフ

この設計には避けられないトレードオフがある：

| 得るもの | 失うもの |
|---------|---------|
| 整合性の保証 | 認知負荷 |
| 複数ビュー対応 | 学習コスト |
| 変更の一元管理 | 「普通のMarkdown」の手軽さ |

利用者は以下を常に考える必要がある：

- 「このデータはどこに書く？」
- 「テンプレートをどう直す？」

これはプログラマー的思考を要求し、学習コストが高い。

### AIによる認知負荷の吸収

トレードオフの「認知負荷と学習コスト」をAIに押し付けることで解決する。

```
従来: 利用者 → 「どこに・どう書くか」を考える → 記述
AI活用: 利用者 → 「何を書くか」だけ伝える → AIが適切に記述
```

利用者は「データの中身」に集中し、「どこに・どう書くか」はAIが判断・実行する。

- 整合性の保証 → 維持（データとビューの分離）
- 認知負荷 → AIが吸収
- 学習コスト → 最小限（自然言語で指示するだけ）

これがMCPサーバー対応の主目的である。
